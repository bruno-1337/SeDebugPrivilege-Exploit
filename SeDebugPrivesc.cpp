#include <iostream>
#include <windows.h>
#include <tlhelp32.h>
#include <string>
#include <iomanip>

using namespace std;

HANDLE GetProcessHandle(DWORD pid)
{
    HANDLE hProcess = OpenProcess(PROCESS_CREATE_PROCESS, false, pid);

    // Check if the handle is valid
    if (hProcess == NULL)
    {
        cout << "Failed to open the process. Error: " << GetLastError() << endl;
        exit(1);
    }

    // Return the handle
    return hProcess;
}

void CreateProcessFromHandle(HANDLE hProcess, std::string command)
{

    int error;
    bool status;
    SIZE_T size = 0;
    LPVOID lpValue = nullptr;
    STARTUPINFOEX si;
    ZeroMemory(&si, sizeof(si));
    si.StartupInfo.cb = sizeof(si);
    si.lpAttributeList = nullptr;

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    // Initialize the thread attribute list
    do
    {
        status = InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
        error = GetLastError();

        if (!status)
        {
            if (si.lpAttributeList != nullptr)
                HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

            si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
            ZeroMemory(si.lpAttributeList, size);
        }
    } while (!status && error == ERROR_INSUFFICIENT_BUFFER);

    // Update the thread attribute with the parent process handle
    do
    {
        if (!status)
        {
            std::cout << "[-] Failed to initialize thread attribute list.\n";
            std::cout << "    |-> " << error << "\n";
            break;
        }

        lpValue = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLE));
        memcpy_s(lpValue, sizeof(HANDLE), &hProcess, sizeof(HANDLE));

        status = UpdateProcThreadAttribute(
            si.lpAttributeList,
            0,
            PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
            lpValue,
            sizeof(HANDLE),
            nullptr,
            nullptr);

        if (!status)
        {
            error = GetLastError();
            std::cout << "[-] Failed to update thread attribute.\n";
            std::cout << "    |-> " << error << "\n";
            break;
        }

        // Create a new process using the specified command line
        status = CreateProcess(nullptr, (LPSTR)command.data(), nullptr, nullptr, false, EXTENDED_STARTUPINFO_PRESENT | CREATE_NO_WINDOW, nullptr, nullptr, &si.StartupInfo, &pi);

        if (!status)
        {
            error = GetLastError();
            std::cout << "[-] Failed to create new process.\n";
            std::cout << "    |-> " << error << "\n";
        }
        else
        {
            std::cout << "[+] New process is created successfully.\n";
            std::cout << "    |-> PID : " << pi.dwProcessId << "\n";
            std::cout << "    |-> TID : " << pi.dwThreadId << "\n";
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    } while (false);

    // Clean up allocated memory
    if (lpValue != nullptr)
        HeapFree(GetProcessHeap(), 0, lpValue);

    if (si.lpAttributeList != nullptr)
        HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

    return;
}

int main(int argc, char* argv[])
{
    if (argc != 3)
    {
        // Print the usage message and exit
        cout << "Usage: " << argv[0] << " <PID> <Program and Arguments>" << endl;
        exit(3);
    }

    DWORD pid = atoi(argv[1]);
    cout << "pid= " << pid << endl;

    // Get the handle of the process with the given PID
    HANDLE hProcess = GetProcessHandle(pid);

    // Create a process for the program from the handle with the given arguments
    CreateProcessFromHandle(hProcess, argv[2]);

    //We done
    CloseHandle(hProcess);
    return 0;
}
